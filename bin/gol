#!/usr/bin/env ruby

# hide cursor until program ends
print "\e[?25l"
at_exit { print "\e[?25h" }

# setup game of life
$LOAD_PATH.unshift File.expand_path('../lib', __dir__)
require 'gol'
game1 = Gol.parse <<RLE
x = 9, y = 8, rule = B3/S23
3o3b3o$obo3bobo$3o3b3o4$b2o3b2o$b2o3b2o!
RLE
game2 = Gol.parse <<RLE
x = 13, y = 33, rule = B3/S23
2o$2o3$3b2o$3b2o2$2o$2o10$b3o$bo$3o4$11b2o$11b2o2$8b2o$8b2o3$11b2o$11b2o!
RLE
game = game2

# set up image processing
require 'chunky_png'
dead_colour  = ChunkyPNG::Color::WHITE
alive_colour = ChunkyPNG::Color::BLACK
side_length  = 10 # px
cells_wide   = 130
cells_high   = 70
def self.b64(str)
  [str].pack('m0')
end

x_offset = (cells_wide-game.x)/2
y_offset = (cells_high-game.y)/2
world = Set.new game.world.map { |x, y| [x+x_offset, y+y_offset] }
loop do
  # construct the image
  image = ChunkyPNG::Image.new(
    side_length*cells_wide,
    side_length*cells_high,
    dead_colour
  )
  world.each do |x, y|
    next if x < 0 || y < 0 || cells_wide <= x || cells_high <= y
    image.rect(
      x*side_length,
      y*side_length,
      x*side_length+side_length,
      y*side_length+side_length,
      alive_colour,
      alive_colour
    )
  end

  # print the image
  png = image.to_blob(fast_rgba: true) # we can use the fast version if we don't have transparency
  $stdout.print "\e[H\e[2J" # go to top-left and clear screen
  $stdout.print(
    "\e]1337;",
    "File=#{b64 'game-of-life'};",
    "size=#{png.bytesize};",
    "inline=1:#{b64 png}",
    "\a\n",
  )

  world = Gol.tick world
end

